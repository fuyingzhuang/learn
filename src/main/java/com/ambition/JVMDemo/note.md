## 类的加载过程

- 加载：通过类加载器将class文件加载到内存中，并为之创建一个java.lang.Class对象
- 链接：将class文件中的二进制数据合并到JVM的运行时环境中
    - 验证：确保加载的类符合JVM规范，没有安全方面的问题
    - 准备：为类的静态变量分配内存，并将其初始化为默认值
    - 解析：把类中的符号引用转换为直接引用
- 初始化：为类的静态变量赋予正确的初始值

## 双亲委派机制

- Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象
  而且加载某个类class文件时，Java虚拟机采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式。
-

工作原理：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求的时候（在它的加载路径下没有找到所需的类）子类加载器才会尝试自己去加载。

- 优势：避免类的重复加载，当父类加载器加载了某个类后，该类就会缓存到父类加载器的缓存区，等下次加载时，如果缓存区有该类，就直接返回，不会再次加载。
- 沙箱安全机制：保证核心API不会被篡改，自定义类加载器不会加载核心API，保证核心API不会被篡改。
- 在JVM中
  表示两个class对象是否相等，首先判断包名是否相同，然后只有在这两个class对象由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类必定不相等。
- JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的，因此JVM使用类加载器来区别类型的加载，每个类加载器都拥有一个独立的类名称空间，因此两个类加载器加载的同一个类，JVM认为他们是不同的类，不相等。

## Java程序对类的使用方式 主动使用和被动使用

- 主动使用：指的是虚拟机必须在程序开始运行前就完成对类的加载，而被动使用指的是虚拟机在程序运行过程中才开始加载某个类。
- 主动使用的情况：
    - 创建类的实例
    - 访问某个类或接口的静态变量，或者对该静态变量赋值
    - 调用类的静态方法
    - 反射
    - 初始化一个类的子类
    - Java虚拟机启动时被标明为启动类的类
    - JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化
- 被动使用的情况：
- 除了以上七种情况，其他使用类的方式都被看作是对类的被动使用，都不会导致类的初始化。

## 运行时数据区

- 程序计数器：
  也称为PC寄存器，是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是线程私有的，生命周期与线程相同。作用:
  PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取下一条指令。在JVM规范中，每一个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，或者如果是在执行本地方法，则是未指定值（undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
- 关于PC寄存器两个常见的问题 1.使用PC寄存器存储字节码指令地址有什么用？2.为什么使用PC寄存器记录当前线程的执行地址呢？
- 因为CPU需要不停的切换各个线程，这时候切换回来以后，就需要知道上次运行到哪里了，所以需要一个地方记录，这个地方就是PC寄存器。
- JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条需要执行的字节码指令，它就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是线程私有的，生命周期与线程相同。
- Java虚拟机栈：每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息
- 栈：是程序运行时的单位 解决程序的运行问题 程序如何执行 或者说如何处理数据
- 堆：是存储的单位 解决的是数据存储的问题 即数据怎么放 放在哪儿
- Java虚拟机栈是什么？
- Java虚拟机栈 早期也叫Java栈 每个线程在创建都会创建一个虚拟机栈 期内部报错一个个的栈帧 对应着一次次的Java方法调用
  是线程私有的 生命周期和线程一致
- 作用：主管Java程序的运行 他需要报错方法的局部变量 部分结果 并参与方法调用和返回
- 优点：栈是一种快速有效的分配存储方式 访问速度仅次于程序计数器
- JVM直接对Java栈的操作只有两个 1. 每个方法执行 伴随着进栈（入栈 压栈） 2. 执行结束后的出栈工作
- 对于栈来说不存在垃圾回首问题
- 每个线程都有自己的栈 栈中的数据 都是以栈帧的形式存储的 只能由本线程访问不能被其他线程访问 在这个线程中的每一个方法
  对应着一个栈帧 栈是一个内存区块 是一个数据集 维系这方法执行过程中的各种数据信息
- 不同线程中所包含的栈帧是不允许存在相互引用的 即不可能在一个栈帧中引用另外一个线程的栈帧 如果当前方法调用了其他方法
  方法返回之际 当前栈帧会传回此方法的执行结果给上一个栈帧 接着当前栈帧会被弹出栈 Java方法中有返回函数的方式 一种是正常函数返回
  一种是抛出异常 不管是哪种方式都会导致栈帧被弹出
- 每个栈帧中存储着 1.局部变量表 2.操作数栈 3.动态链接 4.方法出口信息 5.附加信息
- 局部变量表：是一组变量值存储空间 是一组数组 用于存放方法参数和方法内部定义的局部变量 这些数据类型包括各种基本数据类型和对象引用
  局部变量表的容量是在编译期确定的
  一个栈帧中的局部变量表所需的内存空间在类结构中就确定了 在方法运行期间不会改变
- 操作数栈：是一个后进先出的栈 用于存储计算过程中的临时数据
- 动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用
- 方法出口信息：当一个方法执行完毕后 他需要返回到哪里去执行 记录了方法返回时的指令地址
- 附加信息：虚拟机规范允许具体的虚拟机实现使用附加信息
- 关于Slot的理解：局部变量表最基本的存储单元就是Slot 局部变量表中的槽位是可以重用的 比如一个int类型的数据占据一个槽位
  那么一个long类型的数据占据两个槽位
- 操作数栈的理解：操作数栈是一个后进先出的栈 用于存储计算过程中的临时数据 在方法执行的过程中
  会根据字节码指令往操作数栈中放入数据或者从操作数栈中取出数据 借助执行引擎来完成
- 操作数栈：主要用于保存计算的中间结果 以及方法的参数 返回值
- 动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用 目的是为了支持方法调用过程中动态连接
- 方法的调用：在JVM中 将符号引用转换为调用方法的直接引用与方法的绑定机制相关 分为静态链接和动态链接
- 静态链接：指的是在类加载阶段 将符号引用转换为直接引用的过程
  当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行时保持不变，这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接
- 动态链接：指的是在运行期间将符号引用转换为直接引用的过程 如果被调用的方法在编译期无法被确定下来，只能在程序运行期间通过调用方法的符号引用动态查找的过程称为动态链接
- 早期绑定：指的是在程序运行之前就已经确定了调用的方法地址 这种绑定方式也称为静态绑定
- 晚期绑定：指的是在程序运行期间才能确定调用的方法地址 这种绑定方式也称为动态绑定
- 虚方法和非虚方法：在Java中 除了静态方法 稀有方法 实例构造器 父类方法 static和final方法之外 其他的方法都是虚方法
- 本地方法栈：与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务
- 什么是本地方法？本地方法是一种Java调用非Java代码的方式，它允许Java应用程序通过本地接口调用本地库中的函数 用native关键字修饰
- 为什么要使用本地方法？Java的跨平台性是通过JVM实现的，但是JVM是不能直接调用操作系统的API的，所以需要使用本地方法来调用操作系统的API
- 1、与java环境外交互
- 2、与操作系统交互
- 3、与Sun‘s JAVA API交互
- 本地方法栈的作用：为虚拟机执行Native方法服务 也是线程私有的
- 允许被实现成固定或者是可动态扩展的内存大小
- 1、如果线程请求分配的栈容量超过了本地方法栈允许的最大容量 将会抛出StackOverflowError
- 2、如果本地方法栈动态扩展时无法申请到足够的内存空间 则会抛出OutOfMemoryError
- 本地方法栈使用C语言实现 它的具体做法是Native Method Stack中登记native方法 在Execution Engine执行时加载native库
- Java堆：Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建
- 一个进程对应一个JVM实例，一个JVM实例对应一个Java堆，Java堆是JVM管理的最大的一块内存空间
  一个JVM实例只有一个Java堆，Java堆是被所有线程共享的一块内存区域
- 每一个线程在创建时都会创建一个Java栈和一个程序计数器，但是每一个线程都会共享一个Java堆
- JVM一启动 Java堆就被创建出来了 其空间大小是在JVM启动时就被设定好的
- 堆中不是所有的对象都是共享的 还有一部分对象是线程私有的 tlab thread local allocation buffer
- 几乎所有的示例对象都是在堆上分配的 但是随着JIT编译器的发展 逃逸分析技术的成熟 一些限定在方法逃逸作用域的对象
  有可能被优化成栈上分配
- 在堆中存放的是对象实例 不是方法运行完后就释放的 而是在垃圾回收器进行垃圾回收时才会释放
- 数组和对象可能永远不会存储在栈上 因为栈帧中保存引用 这个引用指向对象或者数组在堆中的位置
- 分区：jdk1.8之前堆内存分为新生代和老年代 1.8之后堆内存分为新生代 老年代和元空间 新生代又分为Eden区和两个Survivor区
- 元空间：JDK1.8之后，将原来的永久代移除，取而代之的是元空间，元空间与永久代最大的区别在于：元空间不在虚拟机中，而是使用本地内存，也即在Java8中，class
  metadata（the virtual machines internal prese ntation of Java class）,被存储在叫做元空间的native
  memory中，而不再是存储在永久代中，这样可以避免永久代的内存溢出问题。
- JVM的相关参数：
    1. 设置堆空间大小的参数 -Xms 用来设置堆空间（年轻代+老年代）的初始化内存大小 -X 是jvm的运行参数 ms是memory start
    2. 设置堆空间最大内存大小 -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小 mx是memory max
    3. 默认堆空间的大小 -Xms等价于-XX:InitialHeapSize 4. 默认堆空间的最大内存大小 -Xmx等价于-XX:MaxHeapSize
    5. 打印堆空间的信息 -XX:+PrintGCDetails
    6. 默认的堆空间大小为电脑物理内存的1/64
    7. 默认的堆空间最大内存大小为电脑物理内存的1/4
- 开发中建议将初始堆内存和最大堆内存设置为相同的值，避免因为堆内存扩容导致的性能抖动
- jps：查看当前运行中的进程
- jstat：查看jvm的统计信息 参数：-gc pid
- 存储在JVM中的对象可以被划分为两类：一类是生命周期较短的瞬时对象 这类对象的创建和消亡都非常迅速 另一类对象的生命周期却非常长
  在某些极端的情况下还能与jvm的生命周期保持一致
- Java堆区进一步细分的话 可以分为年轻代和老年代 其中年轻代又可以划分为Eden区和Servivor0区和Servivor1区 有时候也被叫做from区和to区
  针对Servivor0和针对Servivor1的总结 复制之后有交换 谁空谁是to区
- 默认情况下 新生代占整个堆空间的1/3 老年代占整个堆空间的2/3 设置的参数是-XX:NewRatio=2
- 默认情况下 在新生代中 Eden区和Servivor区的空间比例是8:1:1 设置的参数是-XX:SurvivorRatio=8
- 几乎所有的对象都是在Eden区中分配的 如果Eden区中的空间不足 会触发一次Minor GC 也叫做Young GC
- 可以通过-XMN和-XMX来设置新生代的大小和老年代的空间内存大小
- JVM在进行GC时 并非每次都对（新生代 老年代 方法区）区域一起回收的 大部分时候回收的都是指新生代
- 针对HotSpot VM的实现 它里面的GC回收按照回收区域又分为两大种类型：一种是部分收集（Partial GC） 一种是整堆收集（Full GC）
- 部分收集（Partial GC）：不是完整的收集整个堆区 其中又分为新生代收集和老年代收集和混合收集
- 新生代收集：指的是只是新生代的部分区域进行垃圾回收 Minor GC / Young GC
- 老年代收集：指的是只是老年代的部分区域进行垃圾回收 Major GC / Old GC 注意 很多时候Major GC和Full GC是混淆的
  需要具体分辨是老年代的部分区域还是整个堆区
- 混合收集：指的是新生代和老年代的部分区域进行垃圾回收 目前G1收集器就是一种混合收集的收集器
- 整堆收集（Full GC）：指的是整个堆区的垃圾回收
- 年轻代触发垃圾回收的条件：当Eden区满时 触发Minor GC
- Minor GC会引发STW（Stop The World）现象 在GC的时候 会暂停用户线程 当GC结束后 用户线程才会恢复
- 老年代触发垃圾回收的条件：当老年代空间不足时 触发Major GC
- 出现了Major GC 经常会伴随至少一次的Minor GC (但绝非对的 在Parallel Scavenge收集器的收集策略中 也有直接进行Major
  GC的情况)
- 也就是说当老年代空间不足时，会先触发Minor GC，如果Minor GC后空间还是不足，才会触发Major GC
- Major GC的速度一般会比Minor GC慢10倍以上 STW的时间也会比Minor GC长 如果Major GC后 还是没有足够的空间 会抛出OOM异常
- Full GC是触发机制：
- 1.调用System.gc()时 系统建议执行Full GC 但是不必然执行
- 2.老年代空间不足
- 3.方法区空间不足
- 4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存
- 5.由Eden区 复制到Survivor区的对象的平均大小大于Survivor区的可用内存
- 面试题 为什么需要把Java堆分代？不分代就不能正常工作了吗？
- 其实不分代完全可以 分代的唯一好处就是优化GC的性能 如果没有分代 那么所有的对象都在一块
  就如同把一个学校的人都关在一个教室。GC的时候需要找到哪些对象没有，这样就会对堆的所有区域进行扫描
- 而很多对象是朝生夕死的 如果分代的话 把新创建的一个对象放到某一个地方 当GC的时候 先把这块存储朝生夕死的对象区域进行回收
  这样就会腾出很大的空间出来
- 针对不同年龄段的对象分配原则如下所示：
- 优先分配到Eden区
- 大对象直接分配到老年区 （在开发过程中 尽量避免出现过多的大对象）
- 长期存活的对象分配到老年区
- 动态对象年龄判断（如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代
  无须等到MaxTenuringThreshold中要求的年龄）
- 对象分配TLAB（Thread Local Allocation Buffer）：TLAB是一个线程私有的数据结构，每个线程都有一个TLAB，用于提升对象分配的效率
  为了避免多个线程操作同一地址 需要使用加锁等机制 进而影响分配速度
- TLAB的说明：尽管不是所有的对象实例都能够在TLAB中成功分配内存 但JVM确实是将TLAB作为内存分配的首选
- 在程序中 开发人员可以通过选项 -XX：+/-UseTLAB来开启或者关闭TLAB
- 默认情况下 TLAB空间的内存非常小 仅占有整个Eden区的1% 但是可以通过选项 -XX：TLABWasteTargetPercent来设置TLAB的内存占用比例
- 一旦对象在TLAB中分配内存失败 JVM就会尝试通过加锁机制确保数据操作的原子性 从而直接从Eden区中分配内存
- 为什么要使用TLAB？因为在多线程的情况下 如果不使用TLAB的话 那么多个 线程就会在同一地址上进行操作 这样就会导致数据的混乱
- 面试题 堆是分配对象存储的唯一选择吗？不是的
- 在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：随着JIT编译器的发展 逃逸分析技术的成熟 栈上分配
  标量替换优化技术将会导致一些微妙的变化 所有的对象都分配到堆上也变得渐渐不那么绝对
- 在Java虚拟机中 对象是在Java堆中分配内存的 这是一个普遍的常识 但是 有一种特殊情况 那就是如果经过逃逸分析后
  发现一个对象并没有逃逸出方法的话 那么这个对象就有可能被优化成栈上分配 这样就无须在堆上分配内存 也无须进行垃圾回收
- 此外 基于OpenJDK深度定制的TaoBaoVM 其中创新的GCIH（GC invisible heap）技术实现off-heap 将生命周期较长的Java对象从heap中移至off-heap
  从而减轻GC的压力
- 针对逃逸分析的总结:在开发中能使用局部变量的地方 尽量使用局部变量 这样可以减少对象的创建 提高程序的性能 不要在方法外中创建对象
- 使用逃逸分析，编译器可以对代码做如下优化：
- 1.栈上分配 将堆分配转化为栈分配 如果一个对象在子程序中被分配 要使指向该对象的指针永远不会逃逸 对象可能是栈分配的候选
  而不是堆分配 2.同步省略 如果一个对象被发现只能从一个线程被访问到 那么对于这个对象操作就可以不考虑同步 3.分离对象或者标量替换
  有的对象可能不需要作为一个连续的内存结构存在也可以被访问到 那么对象的部分（或全部）可以不存储在内存而是存储在CPU寄存器中
- 方法区：用于存储已被虚拟机加载的类信息 域信息 常量 静态变量 及即时编译后的代码数据
- 类信息：对每个加载的类型（类class、接口interface、枚举enum、注解annotation）JVM必须在方法区中存储以下类型信息：
- 这个类型的完整的有效的名称（全名=包名.类名）
- 这个类型直接父类的完整有效名（对于interface或是java.lang.Object都没有父类）
- 这个类的修饰符（public abstract final的某个子集）
- 这个类型直接接口的一个有序列表
- 域（Field）信息：JVM必须在方法区中保存类型的所有域的信息以及域的声明顺序 域的相关信息包括 域名称 域类型 域修饰符（public private protected static final volatile transient的某个子集）
- 方法信息：JVM必须保存类型的所有方法的信息 这些信息包括方法的名称 方法的返回类型 方法的参数类型 方法的修饰符（public private protected static final synchronized native abstract的某个子集） 方法的字节码 操作数栈  局部变量表大小 异常表等
- 方法区的基本理解：方法区与Java堆一样 是各个线程共享的内存区域
- 方法区在JVM启动的时候被创建，并且它的实际物理内存可以是不连续的
- 方法区的大小跟堆空间一样 可以选择固定大小或者可扩展
- 方法区的大小决定了系统可以保存多少个类 如果系统定义了太多的类 导致方法区溢出 同样会导致内存溢出异常(常见的溢出情况：大量加载第三方jar包、Tomcat部署的工程过多30-50个、大量动态的生成反射类)
- 关闭JVM时候 就会释放整个区域的内存
- 运行时常量池是方法区的一部分 常量池表是class文件的一部分 用户存放编译期生成的各种字面量与符号引用 这部分内容将在类加载后存放到方法区的运行时常量池中
- 运行时常量池 在加载类和接口到虚拟机后 就会创建对应的运行时常量池
- 运行时常量池中包含多种不同的常量 包括编译期就已经明确的数值字面量 也包括到运行期解析后才能获得的方法或字段引用 此时不再是常量池中的符号地址了 就换成真实地址 运行时常量池 相对于class文件常量池的另一重要特性是 具备动态性
- 运行时常量池类似于传统编程语言中的符号表 但是它所包含的数据却比符号表要更加丰富一些
- 当创建类或接口的运行时常量池时 如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值 JVM就会抛OOM异常
- 方法区的内存回收：方法区的内存回收主要是针对常量池的回收和类型的卸载
- 永久代为什么要被元空间取代？
- 永久代的内存回收效率低下 会导致频繁的Full GC
- 永久代的大小不容易确定
- 永久代会导致内存泄漏
- 永久代的内存分配不方便
- 方法区的垃圾回收:方法区的垃圾回收主要是针对常量池的回收和不再使用的类型的卸载

- 对象的实例化:
- 创建对象的方式:
- new关键字 直接使用new关键字创建对象 Xxx对象的方法(单例模式) 本质也是调用构造方法 工厂模式Xxx.build() 本质也是调用构造方法
- class的newInstance方法 本质也是调用构造方法 只能调用空参的构造器 权限必须是public 过时了
- Constructor的newInstance方法 本质也是调用构造方法 可以调用有参的构造器 权限没有要求
- clone方法 不调用构造方法 需要当前的类实现Cloneable接口 重写clone方法
- 反序列化 从文件/网络中获取对象的二进制流 通过反序列化得到对象
- 第三方库 Objenesis
- 创建对象的步骤:
- 1.判断对象对应的类是否加载 链接 初始化(虚拟机遇到一条new指令 首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的了类是否已经被加载、解析和初始化(即判断类元信息是否存在)。如果没有 那么在双亲委派模式下 使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件 如果没有找到文件 则抛出ClassNotFoundException异常 如果找到 则进行类加载 并且生成对应的Class类对象)
- 
