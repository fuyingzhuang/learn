## 类的加载过程

- 加载：通过类加载器将class文件加载到内存中，并为之创建一个java.lang.Class对象
- 链接：将class文件中的二进制数据合并到JVM的运行时环境中
    - 验证：确保加载的类符合JVM规范，没有安全方面的问题
    - 准备：为类的静态变量分配内存，并将其初始化为默认值
    - 解析：把类中的符号引用转换为直接引用
- 初始化：为类的静态变量赋予正确的初始值

## 双亲委派机制

- Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象
  而且加载某个类class文件时，Java虚拟机采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式。
-

工作原理：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求的时候（在它的加载路径下没有找到所需的类）子类加载器才会尝试自己去加载。

- 优势：避免类的重复加载，当父类加载器加载了某个类后，该类就会缓存到父类加载器的缓存区，等下次加载时，如果缓存区有该类，就直接返回，不会再次加载。
- 沙箱安全机制：保证核心API不会被篡改，自定义类加载器不会加载核心API，保证核心API不会被篡改。
- 在JVM中
  表示两个class对象是否相等，首先判断包名是否相同，然后只有在这两个class对象由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类必定不相等。
- JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的，因此JVM使用类加载器来区别类型的加载，每个类加载器都拥有一个独立的类名称空间，因此两个类加载器加载的同一个类，JVM认为他们是不同的类，不相等。

## Java程序对类的使用方式 主动使用和被动使用

- 主动使用：指的是虚拟机必须在程序开始运行前就完成对类的加载，而被动使用指的是虚拟机在程序运行过程中才开始加载某个类。
- 主动使用的情况：
    - 创建类的实例
    - 访问某个类或接口的静态变量，或者对该静态变量赋值
    - 调用类的静态方法
    - 反射
    - 初始化一个类的子类
    - Java虚拟机启动时被标明为启动类的类
    - JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化
- 被动使用的情况：
- 除了以上七种情况，其他使用类的方式都被看作是对类的被动使用，都不会导致类的初始化。

## 运行时数据区

- 程序计数器：
  也称为PC寄存器，是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是线程私有的，生命周期与线程相同。作用:
  PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取下一条指令。在JVM规范中，每一个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，或者如果是在执行本地方法，则是未指定值（undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
- 关于PC寄存器两个常见的问题 1.使用PC寄存器存储字节码指令地址有什么用？2.为什么使用PC寄存器记录当前线程的执行地址呢？
- 因为CPU需要不停的切换各个线程，这时候切换回来以后，就需要知道上次运行到哪里了，所以需要一个地方记录，这个地方就是PC寄存器。
- JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条需要执行的字节码指令，它就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是线程私有的，生命周期与线程相同。
- Java虚拟机栈：每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息
- 栈：是程序运行时的单位 解决程序的运行问题 程序如何执行 或者说如何处理数据
- 堆：是存储的单位 解决的是数据存储的问题 即数据怎么放 放在哪儿
- Java虚拟机栈是什么？
- Java虚拟机栈 早期也叫Java栈 每个线程在创建都会创建一个虚拟机栈 期内部报错一个个的栈帧 对应着一次次的Java方法调用
  是线程私有的 生命周期和线程一致
- 作用：主管Java程序的运行 他需要报错方法的局部变量 部分结果 并参与方法调用和返回
- 优点：栈是一种快速有效的分配存储方式 访问速度仅次于程序计数器
- JVM直接对Java栈的操作只有两个 1. 每个方法执行 伴随着进栈（入栈 压栈） 2. 执行结束后的出栈工作
- 对于栈来说不存在垃圾回首问题
- 每个线程都有自己的栈 栈中的数据 都是以栈帧的形式存储的 只能由本线程访问不能被其他线程访问 在这个线程中的每一个方法
  对应着一个栈帧 栈是一个内存区块 是一个数据集 维系这方法执行过程中的各种数据信息
- 不同线程中所包含的栈帧是不允许存在相互引用的 即不可能在一个栈帧中引用另外一个线程的栈帧 如果当前方法调用了其他方法
  方法返回之际 当前栈帧会传回此方法的执行结果给上一个栈帧 接着当前栈帧会被弹出栈 Java方法中有返回函数的方式 一种是正常函数返回
  一种是抛出异常 不管是哪种方式都会导致栈帧被弹出
- 本地方法栈：与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务
- Java堆：Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建
- 元空间：JDK1.8之后，将原来的永久代移除，取而代之的是元空间，元空间与永久代最大的区别在于：元空间不在虚拟机中，而是使用本地内存，也即在Java8中，class
  metadata（the virtual machines internal presentation of Java class）,被存储在叫做元空间的native
  memory中，而不再是存储在永久代中，这样可以避免永久代的内存溢出问题。
