## 类的加载过程

- 加载：通过类加载器将class文件加载到内存中，并为之创建一个java.lang.Class对象
- 链接：将class文件中的二进制数据合并到JVM的运行时环境中
    - 验证：确保加载的类符合JVM规范，没有安全方面的问题
    - 准备：为类的静态变量分配内存，并将其初始化为默认值
    - 解析：把类中的符号引用转换为直接引用
- 初始化：为类的静态变量赋予正确的初始值

## 双亲委派机制

- Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象
  而且加载某个类class文件时，Java虚拟机采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式。
-
工作原理：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求的时候（在它的加载路径下没有找到所需的类）子类加载器才会尝试自己去加载。
- 优势：避免类的重复加载，当父类加载器加载了某个类后，该类就会缓存到父类加载器的缓存区，等下次加载时，如果缓存区有该类，就直接返回，不会再次加载。
- 沙箱安全机制：保证核心API不会被篡改，自定义类加载器不会加载核心API，保证核心API不会被篡改。
- 在JVM中
  表示两个class对象是否相等，首先判断包名是否相同，然后只有在这两个class对象由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类必定不相等。
- JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的，因此JVM使用类加载器来区别类型的加载，每个类加载器都拥有一个独立的类名称空间，因此两个类加载器加载的同一个类，JVM认为他们是不同的类，不相等。

## Java程序对类的使用方式 主动使用和被动使用
- 主动使用：指的是虚拟机必须在程序开始运行前就完成对类的加载，而被动使用指的是虚拟机在程序运行过程中才开始加载某个类。
- 主动使用的情况：
    - 创建类的实例
    - 访问某个类或接口的静态变量，或者对该静态变量赋值
    - 调用类的静态方法
    - 反射
    - 初始化一个类的子类
    - Java虚拟机启动时被标明为启动类的类
    - JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化
- 被动使用的情况：
- 除了以上七种情况，其他使用类的方式都被看作是对类的被动使用，都不会导致类的初始化。
## 运行时数据区
- 程序计数器：当前线程所执行的字节码的行号指示器
- Java虚拟机栈：每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息
- 本地方法栈：与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务
- Java堆：Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建
- 元空间：JDK1.8之后，将原来的永久代移除，取而代之的是元空间，元空间与永久代最大的区别在于：元空间不在虚拟机中，而是使用本地内存，也即在Java8中，class metadata（the virtual machines internal presentation of Java class）,被存储在叫做元空间的native memory中，而不再是存储在永久代中，这样可以避免永久代的内存溢出问题。
